import { AssetUrlResolver } from '../types/dependencies';
import { createRequestLogger } from '../utils/logger';

// Define a type for the logger to make it easier to work with
type Logger = ReturnType<typeof createRequestLogger>;

/**
 * Parameters required to request a download URL.
 * This interface encapsulates all the information needed to locate and generate
 * a download URL for an audio asset in the system.
 *
 * @interface
 * @example
 * // Request a full audiobook URL
 * const params: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'full',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 *
 * // Request a specific chapter URL
 * const chapterParams: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'chapter',
 *   chapter: '3',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   * This is typically a URL-friendly version of the book title, like 'the-odyssey'.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   * - 'full': Retrieve the complete audiobook as a single file
   * - 'chapter': Retrieve a specific chapter (requires the 'chapter' parameter)
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   * For most books, this is a number (as a string) corresponding to the book chapter,
   * though some special chapters might have different identifiers.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   * This helps with tracing requests across different components and in logs.
   */
  correlationId?: string;
}

/**
 * Service responsible for generating download URLs for audio files.
 * Uses the unified AssetService for consistent asset handling.
 *
 * URL Generation Approach:
 * -----------------------
 * The service uses the unified AssetService to generate URLs for audio assets.
 * This provides a consistent interface for all asset operations and handles
 * retry logic, error handling, and logging internally.
 *
 * This approach ensures:
 * - Consistent URL generation across all asset types
 * - Robust error handling with retry logic
 * - Detailed structured logging
 * - No dependence on specific storage backends (like Digital Ocean)
 *
 * The service follows these steps:
 * 1. Determines the appropriate asset name based on download type and chapter
 * 2. Uses the AssetService to generate a URL for the asset
 * 3. Returns the URL directly to the caller
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   * Initializes the service with its required dependencies through dependency injection.
   * This constructor follows the Dependency Inversion Principle by accepting interfaces
   * rather than concrete implementations, which improves testability and flexibility.
   *
   * @param assetService - Unified service for asset operations
   * @example
   * const downloadService = new DownloadService(
   *   createAssetService({ correlationId: 'abcd-1234' })
   * );
   */
  constructor(private readonly assetService: AssetUrlResolver) {}

  /**
   * Returns the asset service instance used by this download service
   * This is used by the proxy handler for direct asset access
   *
   * @returns The AssetService instance
   */
  getAssetService(): AssetUrlResolver {
    return this.assetService;
  }

  /**
   * Validates request parameters for downloading assets.
   * Ensures all required parameters are present for the requested download type.
   *
   * @param params - The download request parameters
   * @param log - Optional logger for recording validation errors
   * @throws Error if parameters are invalid
   */
  private validateRequestParams(params: DownloadRequestParams, log?: Logger): void {
    const { slug, type, chapter } = params;

    // Chapter is required when requesting a specific chapter
    if (type === 'chapter' && !chapter) {
      log?.error({
        msg: 'Missing chapter parameter for chapter download',
        slug,
        type,
        action: 'downloadService.validateRequestParams.error',
      });
      throw new Error('Chapter parameter is required when type is "chapter"');
    }
  }

  /**
   * Generates paths for the requested asset type
   * Used for internal testing and verification
   *
   * @param slug - The book slug
   * @param type - The download type (full or chapter)
   * @param log - Logger for error recording
   * @param chapter - Optional chapter identifier
   * @returns Object containing generated paths
   */
  generatePaths(
    slug: string,
    type: 'full' | 'chapter',
    // Create a simple adapter interface that can handle both string-based and object-based loggers
    log: {
      info: (messageOrObj: string | Record<string, unknown>) => void;
      error: (messageOrObj: string | Record<string, unknown>) => void;
    },
    chapter?: string
  ) {
    // Generate paths in a simplified way for testing only
    const cdnBase = 'https://brainrot-publishing.nyc3.cdn.digitaloceanspaces.com';

    // Match the expected path formats from the tests
    const legacyPath =
      type === 'full'
        ? `/${slug}/audio/full-audiobook.mp3`
        : `/${slug}/audio/book-${chapter?.padStart(2, '0')}.mp3`;

    // For CDN URLs, use the format without the /assets prefix
    const cdnPath =
      type === 'full'
        ? `/${slug}/audio/full-audiobook.mp3`
        : `/${slug}/audio/book-${chapter?.padStart(2, '0')}.mp3`;

    return {
      cdnUrl: `${cdnBase}${cdnPath}`,
      legacyPath: legacyPath,
    };
  }

  /**
   * Generates the appropriate asset name based on the download type and chapter.
   *
   * @param type - The type of download (full or chapter)
   * @param chapter - Optional chapter identifier, required for chapter downloads
   * @returns The asset name to be used for URL generation
   */
  private generateAssetName(type: 'full' | 'chapter', chapter?: string): string {
    if (type === 'full') {
      return 'full-audiobook.mp3';
    }

    // We can safely assume chapter exists here because validateRequestParams ensures it
    // Using a fallback empty string (which will cause validation to fail) rather than non-null assertion
    const chapterStr = chapter || '';
    const paddedChapter = this.zeroPad(parseInt(chapterStr, 10), 2);
    return `chapter-${paddedChapter}.mp3`;
  }

  /**
   * Logs successful URL generation with appropriate context.
   *
   * @param log - Optional logger
   * @param params - The download request parameters
   * @param assetName - The generated asset name
   */
  private logRequestSuccess(
    log: Logger | undefined,
    params: DownloadRequestParams,
    assetName: string
  ): void {
    const { slug, type, chapter } = params;

    log?.info({
      msg: 'Successfully generated download URL',
      slug,
      type,
      chapter,
      assetName,
      action: 'downloadService.getDownloadUrl.success',
    });
  }

  /**
   * Logs errors during URL generation with appropriate context.
   *
   * @param log - Optional logger
   * @param params - The download request parameters
   * @param assetName - The generated asset name
   * @param error - The error that occurred
   */
  private logRequestError(
    log: Logger | undefined,
    params: DownloadRequestParams,
    assetName: string,
    error: unknown
  ): void {
    const { slug, type, chapter } = params;

    log?.error({
      msg: 'Failed to get asset URL',
      slug,
      type,
      chapter,
      assetName,
      error: error instanceof Error ? error.message : String(error),
      action: 'downloadService.getDownloadUrl.error',
    });
  }

  /**
   * Attempts to get an asset URL from the resolver
   *
   * @param legacyPath - The legacy path to resolve
   * @param params - The download request parameters for logging
   * @param log - Optional logger for recording status
   * @returns The resolved URL or null if not found
   */
  private async tryGetAssetUrl(
    legacyPath: string,
    params: DownloadRequestParams,
    log?: Logger
  ): Promise<string | null> {
    try {
      // Try to get URL with fallback
      const url = await this.assetService.getAssetUrlWithFallback(legacyPath);

      // If we get a valid URL, log and return it
      if (url && url.trim() !== '') {
        log?.info({
          msg: 'Successfully generated download URL',
          ...params,
          url,
          action: 'downloadService.getDownloadUrl.success',
        });
        return url;
      }

      // Return null if URL is empty
      return null;
    } catch (error) {
      // Log error
      log?.error({
        msg: 'Error getting asset URL, will use fallback',
        ...params,
        error: error instanceof Error ? error.message : String(error),
        action: 'downloadService.getDownloadUrl.error',
      });

      // Return null to trigger fallback
      return null;
    }
  }

  /**
   * Gets a fallback CDN URL
   *
   * @param slug - The book slug
   * @param type - The download type
   * @param chapter - Optional chapter number
   * @param log - Optional logger
   * @returns The CDN URL
   */
  private getFallbackCdnUrl(
    slug: string,
    type: 'full' | 'chapter',
    chapter?: string,
    log?: Logger
  ): string {
    // Create a compatible logger adapter for the generatePaths method
    const logAdapter = {
      info: (messageOrObj: string | Record<string, unknown>) => {
        if (typeof messageOrObj === 'string') {
          log?.info({ msg: messageOrObj });
        } else {
          log?.info(messageOrObj);
        }
      },
      error: (messageOrObj: string | Record<string, unknown>) => {
        if (typeof messageOrObj === 'string') {
          log?.error({ msg: messageOrObj });
        } else {
          log?.error(messageOrObj);
        }
      },
    };

    // Generate paths to get the CDN URL
    const { cdnUrl } = this.generatePaths(slug, type, logAdapter, chapter);

    // Log fallback
    log?.info({
      msg: 'Using CDN fallback URL',
      slug,
      type,
      chapter,
      url: cdnUrl,
      action: 'downloadService.getDownloadUrl.fallback',
    });

    return cdnUrl;
  }

  /**
   * Gets a download URL for the requested asset
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the asset URL
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Create a logger with correlation ID if available
    const log = correlationId ? createRequestLogger(correlationId) : undefined;

    // Log method entry with detailed request parameters
    log?.debug({
      msg: 'Getting download URL',
      ...params,
      action: 'downloadService.getDownloadUrl.entry',
    });

    // Validate request parameters
    this.validateRequestParams(params, log);

    // Create a compatible logger adapter for the generatePaths method
    const logAdapter = {
      info: (messageOrObj: string | Record<string, unknown>) => {
        if (typeof messageOrObj === 'string') {
          log?.info({ msg: messageOrObj });
        } else {
          log?.info(messageOrObj);
        }
      },
      error: (messageOrObj: string | Record<string, unknown>) => {
        if (typeof messageOrObj === 'string') {
          log?.error({ msg: messageOrObj });
        } else {
          log?.error(messageOrObj);
        }
      },
    };

    // Generate asset path
    const { legacyPath } = this.generatePaths(slug, type, logAdapter, chapter);

    // Try to get URL from asset service
    const url = await this.tryGetAssetUrl(legacyPath, params, log);

    // If we got a valid URL, return it; otherwise use fallback
    return url || this.getFallbackCdnUrl(slug, type, chapter, log);
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   * This utility ensures consistent file path construction with properly formatted numbers.
   *
   * @param num - The number to pad with leading zeros
   * @param places - The desired length after padding (total number of digits)
   * @returns A string with the padded number
   * @private
   * @example
   * // Returns "01" for chapter 1
   * this.zeroPad(1, 2);
   *
   * // Returns "001" for chapter 1 with 3 digits
   * this.zeroPad(1, 3);
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
