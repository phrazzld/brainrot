import {
  AssetNotFoundError,
  AssetUrlResolver,
  S3SignedUrlGenerator,
  SigningError,
} from '../types/dependencies';
import { createRequestLogger } from '../utils/logger';

/**
 * Parameters required to request a download URL.
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   */
  correlationId?: string;
}

/**
 * Service responsible for orchestrating the download URL resolution process.
 * Handles the logic to determine whether to return a Blob URL or generate a signed S3 URL.
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   *
   * @param assetUrlResolver - Service that resolves asset URLs with fallback logic
   * @param s3SignedUrlGenerator - Service that generates signed URLs for S3 objects
   * @param s3Endpoint - The S3 endpoint URL used to determine if URL signing is needed
   */
  constructor(
    private readonly assetUrlResolver: AssetUrlResolver,
    private readonly s3SignedUrlGenerator: S3SignedUrlGenerator,
    private readonly s3Endpoint: string
  ) {}

  /**
   * Gets a download URL for the requested asset.
   * Determines whether to return a Blob URL or a signed S3 URL based on the resolved URL.
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the final download URL
   * @throws {AssetNotFoundError} When the requested asset cannot be found
   * @throws {SigningError} When S3 URL signing fails
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Create a logger with correlation ID if available
    const log = correlationId ? createRequestLogger(correlationId) : undefined;

    // Log method entry with detailed request parameters
    log?.debug({
      msg: 'Getting download URL',
      slug,
      type,
      chapter,
      action: 'downloadService.getDownloadUrl.entry',
    });

    // Generate the legacy path based on the request parameters
    const legacyPath = this.generateLegacyPath(slug, type, chapter, log);

    try {
      // Attempt to get the asset URL with fallback mechanism
      const resolvedUrl = await this.assetUrlResolver.getAssetUrlWithFallback(legacyPath);

      // If no URL was resolved, throw an AssetNotFoundError
      if (!resolvedUrl) {
        log?.warn({
          msg: 'Asset not found',
          legacyPath,
          action: 'downloadService.assetNotFound',
        });
        throw new AssetNotFoundError(`Asset not found: ${legacyPath}`);
      }

      // Check if the resolved URL is an S3 URL that needs signing
      if (resolvedUrl.includes(this.s3Endpoint)) {
        log?.info({
          msg: 'Generating signed URL for S3 path',
          s3Path: resolvedUrl,
          action: 'downloadService.generateSignedUrl.start',
        });

        try {
          // Generate a signed URL for the S3 path
          const signedUrl = await this.s3SignedUrlGenerator.createSignedS3Url(resolvedUrl);

          log?.debug({
            msg: 'Successfully generated signed URL',
            action: 'downloadService.generateSignedUrl.success',
          });

          return signedUrl;
        } catch (error) {
          log?.error({
            msg: 'Failed to generate signed URL',
            s3Path: resolvedUrl,
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : undefined,
            action: 'downloadService.generateSignedUrl.error',
          });

          // Wrap any signing errors and rethrow
          throw new SigningError(
            `Failed to generate signed URL for ${resolvedUrl}`,
            error instanceof Error ? error : undefined
          );
        }
      }

      // If not an S3 URL, return the resolved URL directly (e.g., Blob URL)
      log?.debug({
        msg: 'Returning direct Blob URL',
        urlType: 'blob',
        action: 'downloadService.blobUrlFound',
      });

      return resolvedUrl;
    } catch (error) {
      // If the resolver already threw an AssetNotFoundError, propagate it
      if (error instanceof AssetNotFoundError) {
        throw error;
      }

      // If it's a SigningError, propagate it
      if (error instanceof SigningError) {
        throw error;
      }

      // Log unexpected errors with structured data
      log?.error({
        msg: 'Unexpected error resolving URL',
        legacyPath,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        action: 'downloadService.unexpectedError',
      });

      // Otherwise, wrap in a new AssetNotFoundError
      throw new AssetNotFoundError(
        `Failed to resolve URL for ${legacyPath}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Generates the legacy file path based on request parameters.
   *
   * @param slug - The book slug
   * @param type - The download type (full or chapter)
   * @param chapter - Optional chapter number (required when type is 'chapter')
   * @param log - Optional logger instance for structured logging
   * @returns The legacy file path
   * @private
   * @throws {Error} When type is 'chapter' but no chapter parameter is provided
   */
  private generateLegacyPath(
    slug: string,
    type: 'full' | 'chapter',
    chapter?: string,
    log?: ReturnType<typeof createRequestLogger>
  ): string {
    if (type === 'full') {
      const path = `/${slug}/audio/full-audiobook.mp3`;
      log?.debug({
        msg: 'Generated full audiobook path',
        slug,
        path,
        action: 'downloadService.generateLegacyPath.full',
      });
      return path;
    } else {
      if (!chapter) {
        log?.error({
          msg: 'Missing chapter parameter for chapter download',
          slug,
          type,
          action: 'downloadService.generateLegacyPath.error',
        });
        throw new Error('Chapter parameter is required when type is "chapter"');
      }

      const paddedChapter = this.zeroPad(parseInt(chapter, 10), 2);
      const path = `/${slug}/audio/book-${paddedChapter}.mp3`;
      log?.debug({
        msg: 'Generated chapter audiobook path',
        slug,
        chapter: paddedChapter,
        path,
        action: 'downloadService.generateLegacyPath.chapter',
      });
      return path;
    }
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   *
   * @param num - The number to pad
   * @param places - The desired length after padding
   * @returns A string with the padded number
   * @private
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
