import { AssetService, AssetType } from '../types/assets';
import { AssetNotFoundError } from '../types/dependencies';
import { createRequestLogger } from '../utils/logger';

/**
 * Parameters required to request a download URL.
 * This interface encapsulates all the information needed to locate and generate
 * a download URL for an audio asset in the system.
 *
 * @interface
 * @example
 * // Request a full audiobook URL
 * const params: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'full',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 *
 * // Request a specific chapter URL
 * const chapterParams: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'chapter',
 *   chapter: '3',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   * This is typically a URL-friendly version of the book title, like 'the-odyssey'.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   * - 'full': Retrieve the complete audiobook as a single file
   * - 'chapter': Retrieve a specific chapter (requires the 'chapter' parameter)
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   * For most books, this is a number (as a string) corresponding to the book chapter,
   * though some special chapters might have different identifiers.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   * This helps with tracing requests across different components and in logs.
   */
  correlationId?: string;
}

/**
 * Service responsible for generating download URLs for audio files.
 * Uses the unified AssetService for consistent asset handling.
 *
 * URL Generation Approach:
 * -----------------------
 * The service uses the unified AssetService to generate URLs for audio assets.
 * This provides a consistent interface for all asset operations and handles
 * retry logic, error handling, and logging internally.
 *
 * This approach ensures:
 * - Consistent URL generation across all asset types
 * - Robust error handling with retry logic
 * - Detailed structured logging
 * - No dependence on specific storage backends (like Digital Ocean)
 *
 * The service follows these steps:
 * 1. Determines the appropriate asset name based on download type and chapter
 * 2. Uses the AssetService to generate a URL for the asset
 * 3. Returns the URL directly to the caller
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   * Initializes the service with its required dependencies through dependency injection.
   * This constructor follows the Dependency Inversion Principle by accepting interfaces
   * rather than concrete implementations, which improves testability and flexibility.
   *
   * @param assetService - Unified service for asset operations
   * @example
   * const downloadService = new DownloadService(
   *   createAssetService({ correlationId: 'abcd-1234' })
   * );
   */
  constructor(private readonly assetService: AssetService) {}

  /**
   * Returns the asset service instance used by this download service
   * This is used by the proxy handler for direct asset access
   *
   * @returns The AssetService instance
   */
  getAssetService(): AssetService {
    return this.assetService;
  }

  /**
   * Gets a download URL for the requested asset
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the asset URL
   * @throws {AssetNotFoundError} When the requested asset cannot be found
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Create a logger with correlation ID if available
    const log = correlationId ? createRequestLogger(correlationId) : undefined;

    // Log method entry with detailed request parameters
    log?.debug({
      msg: 'Getting download URL',
      slug,
      type,
      chapter,
      action: 'downloadService.getDownloadUrl.entry',
    });

    // Generate the appropriate asset name based on type and chapter
    let assetName: string;
    if (type === 'full') {
      assetName = 'full-audiobook.mp3';
    } else {
      if (!chapter) {
        log?.error({
          msg: 'Missing chapter parameter for chapter download',
          slug,
          type,
          action: 'downloadService.getDownloadUrl.error',
        });
        throw new Error('Chapter parameter is required when type is "chapter"');
      }

      // Format chapter number with leading zeros
      const paddedChapter = this.zeroPad(parseInt(chapter, 10), 2);
      assetName = `chapter-${paddedChapter}.mp3`;
    }

    try {
      // Get URL from the AssetService
      const url = await this.assetService.getAssetUrl(AssetType.AUDIO, slug, assetName);

      log?.info({
        msg: 'Successfully generated download URL',
        slug,
        type,
        chapter,
        assetName,
        action: 'downloadService.getDownloadUrl.success',
      });

      return url;
    } catch (error) {
      // Log error and rethrow as AssetNotFoundError
      log?.error({
        msg: 'Failed to get asset URL',
        slug,
        type,
        chapter,
        assetName,
        error: error instanceof Error ? error.message : String(error),
        action: 'downloadService.getDownloadUrl.error',
      });

      throw new AssetNotFoundError(
        `Failed to get URL for ${slug}/${type}/${chapter || ''}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   * This utility ensures consistent file path construction with properly formatted numbers.
   *
   * @param num - The number to pad with leading zeros
   * @param places - The desired length after padding (total number of digits)
   * @returns A string with the padded number
   * @private
   * @example
   * // Returns "01" for chapter 1
   * this.zeroPad(1, 2);
   *
   * // Returns "001" for chapter 1 with 3 digits
   * this.zeroPad(1, 3);
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
