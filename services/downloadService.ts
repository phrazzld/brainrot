import { AssetNotFoundError, AssetUrlResolver } from '../types/dependencies';
import { createRequestLogger } from '../utils/logger';

/**
 * Parameters required to request a download URL.
 * This interface encapsulates all the information needed to locate and generate
 * a download URL for an audio asset in the system.
 *
 * @interface
 * @example
 * // Request a full audiobook URL
 * const params: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'full',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 *
 * // Request a specific chapter URL
 * const chapterParams: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'chapter',
 *   chapter: '3',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   * This is typically a URL-friendly version of the book title, like 'the-odyssey'.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   * - 'full': Retrieve the complete audiobook as a single file
   * - 'chapter': Retrieve a specific chapter (requires the 'chapter' parameter)
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   * For most books, this is a number (as a string) corresponding to the book chapter,
   * though some special chapters might have different identifiers.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   * This helps with tracing requests across different components and in logs.
   */
  correlationId?: string;
}

/**
 * Service responsible for generating download URLs for audio files.
 * Uses direct CDN URLs by default with fallback to Vercel Blob if available.
 *
 * URL Generation Approach:
 * -----------------------
 * 1. For audio files, we use Digital Ocean CDN URLs as the primary source
 *    Format: https://{bucket}.{region}.cdn.digitaloceanspaces.com/{slug}/audio/...
 *
 * 2. As a fallback, we try to resolve URLs through the AssetUrlResolver which
 *    may attempt to find the asset in Vercel Blob storage
 *
 * 3. The system never uses S3 signed URLs - all assets are accessed via public
 *    direct URLs, either from Digital Ocean CDN or Vercel Blob
 *
 * The service follows these steps:
 * 1. Generates appropriate CDN and legacy paths based on book slug, type, and chapter
 * 2. Attempts to resolve the asset URL via AssetUrlResolver as fallback
 * 3. Returns either the Blob URL if found, or defaults to the CDN URL
 *
 * This approach ensures:
 * - No S3 credentials are required
 * - URLs work consistently across environments
 * - Fallback mechanisms increase resilience
 * - Path generation is consistent for all audio file types
 *
 * The service provides structured logging for all key operations to aid in debugging.
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   * Initializes the service with its required dependencies through dependency injection.
   * This constructor follows the Dependency Inversion Principle by accepting interfaces
   * rather than concrete implementations, which improves testability and flexibility.
   *
   * @param assetUrlResolver - Service that resolves asset URLs with fallback logic
   * @param s3SignedUrlGenerator - Service that generates signed URLs for S3 objects
   * @param s3Endpoint - The S3 endpoint URL used to determine if URL signing is needed
   * @example
   * const downloadService = new DownloadService(
   *   assetUrlResolver,
   *   createS3SignedUrlGenerator(),
   *   process.env.SPACES_ENDPOINT
   * );
   */
  constructor(private readonly assetUrlResolver: AssetUrlResolver) {}

  /**
   * Gets a download URL for the requested asset with fallback mechanisms.
   *
   * This method tries the following sources in order:
   * 1. Direct CDN URL (Digital Ocean CDN)
   * 2. Vercel Blob URL (via assetUrlResolver)
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the final download URL
   * @throws {AssetNotFoundError} When the requested asset cannot be found in any location
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Create a logger with correlation ID if available
    const log = correlationId ? createRequestLogger(correlationId) : undefined;

    // Log method entry with detailed request parameters
    log?.debug({
      msg: 'Getting download URL',
      slug,
      type,
      chapter,
      action: 'downloadService.getDownloadUrl.entry',
    });

    // Generate paths for different storage locations
    const { cdnUrl, legacyPath } = this.generatePaths(slug, type, chapter, log);

    // First try the direct CDN URL (most reliable source)
    log?.debug({
      msg: 'Using direct CDN URL first',
      cdnUrl,
      action: 'downloadService.getDownloadUrl.tryCdnUrl',
    });

    // The CDN URL is our primary source and should always work
    // But we'll implement fallback logic for robustness
    try {
      // Try to resolve with fallback mechanism in case CDN is unavailable
      const resolvedUrl = await this.resolveAssetUrl(legacyPath, log);
      if (resolvedUrl) {
        log?.debug({
          msg: 'Blob URL found as fallback',
          blobUrl: resolvedUrl,
          action: 'downloadService.getDownloadUrl.blobUrlFound',
        });
        return resolvedUrl;
      }
    } catch (error) {
      // If asset resolver fails, continue with CDN URL
      log?.debug({
        msg: 'Blob fallback failed, using CDN URL',
        error: error instanceof Error ? error.message : String(error),
        action: 'downloadService.getDownloadUrl.fallbackFailed',
      });
    }

    // Return the CDN URL as our final result
    return cdnUrl;
  }

  /**
   * Resolves an asset URL using the asset resolver service.
   *
   * @param legacyPath - The legacy path to resolve
   * @param log - Optional logger instance
   * @returns The resolved URL
   * @throws {AssetNotFoundError} When the asset cannot be found
   * @private
   */
  private async resolveAssetUrl(
    legacyPath: string,
    log?: ReturnType<typeof createRequestLogger>
  ): Promise<string> {
    // Attempt to get the asset URL with fallback mechanism
    const resolvedUrl = await this.assetUrlResolver.getAssetUrlWithFallback(legacyPath);

    // If no URL was resolved, throw an AssetNotFoundError
    if (!resolvedUrl) {
      log?.warn({
        msg: 'Asset not found',
        legacyPath,
        action: 'downloadService.assetNotFound',
      });
      throw new AssetNotFoundError(`Asset not found: ${legacyPath}`);
    }

    return resolvedUrl;
  }

  /**
   * Processes a resolved URL.
   * Since we're using public URLs, this simply returns the URL directly.
   *
   * @param resolvedUrl - The URL to process
   * @param log - Optional logger instance
   * @returns The final URL
   * @private
   */
  private async processResolvedUrl(
    resolvedUrl: string,
    log?: ReturnType<typeof createRequestLogger>
  ): Promise<string> {
    // Simply return the resolved URL directly - no signing needed
    log?.debug({
      msg: 'Returning direct URL',
      url: resolvedUrl,
      action: 'downloadService.urlFound',
    });

    return resolvedUrl;
  }

  /**
   * Handles errors that occur during URL resolution.
   *
   * @param error - The error that occurred
   * @param legacyPath - The legacy path being processed
   * @param log - Optional logger instance
   * @returns Never returns as it always throws an error
   * @throws {AssetNotFoundError|SigningError} The appropriate error type
   * @private
   */
  private handleUrlResolutionError(
    error: unknown,
    legacyPath: string,
    log?: ReturnType<typeof createRequestLogger>
  ): never {
    // If the resolver already threw an AssetNotFoundError, propagate it
    if (error instanceof AssetNotFoundError) {
      throw error;
    }

    // Log unexpected errors with structured data
    log?.error({
      msg: 'Unexpected error resolving URL',
      legacyPath,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      action: 'downloadService.unexpectedError',
    });

    // Otherwise, wrap in a new AssetNotFoundError
    throw new AssetNotFoundError(
      `Failed to resolve URL for ${legacyPath}: ${error instanceof Error ? error.message : String(error)}`
    );
  }

  /**
   * Generates the file paths for various storage locations based on request parameters.
   * Supports both Digital Ocean CDN and Vercel Blob paths for fallback mechanisms.
   *
   * @param slug - The book slug
   * @param type - The download type (full or chapter)
   * @param chapter - Optional chapter number (required when type is 'chapter')
   * @param log - Optional logger instance for structured logging
   * @returns An object containing paths for different storage locations
   * @private
   * @throws {Error} When type is 'chapter' but no chapter parameter is provided
   */
  private generatePaths(
    slug: string,
    type: 'full' | 'chapter',
    chapter?: string,
    log?: ReturnType<typeof createRequestLogger>
  ): { cdnUrl: string; legacyPath: string } {
    // Get bucket and region from environment variables with defaults
    const bucket =
      process.env.DO_SPACES_BUCKET || process.env.SPACES_BUCKET_NAME || 'brainrot-publishing';
    const region = 'nyc3'; // This is hardcoded as it's consistent

    // Generate both CDN URL and legacy path for fallback
    if (type === 'full') {
      // Generate the appropriate paths for full audiobook
      const cdnUrl = `https://${bucket}.${region}.cdn.digitaloceanspaces.com/${slug}/audio/full-audiobook.mp3`;
      const legacyPath = `/${slug}/audio/full-audiobook.mp3`;

      log?.debug({
        msg: 'Generated full audiobook paths',
        slug,
        cdnUrl,
        legacyPath,
        bucket,
        region,
        action: 'downloadService.generatePaths.full',
      });

      return { cdnUrl, legacyPath };
    } else {
      if (!chapter) {
        log?.error({
          msg: 'Missing chapter parameter for chapter download',
          slug,
          type,
          action: 'downloadService.generatePaths.error',
        });
        throw new Error('Chapter parameter is required when type is "chapter"');
      }

      const paddedChapter = this.zeroPad(parseInt(chapter, 10), 2);

      // Generate the paths for chapter audiobook
      const cdnUrl = `https://${bucket}.${region}.cdn.digitaloceanspaces.com/${slug}/audio/book-${paddedChapter}.mp3`;
      const legacyPath = `/${slug}/audio/book-${paddedChapter}.mp3`;

      log?.debug({
        msg: 'Generated chapter audiobook paths',
        slug,
        chapter: paddedChapter,
        cdnUrl,
        legacyPath,
        bucket,
        region,
        action: 'downloadService.generatePaths.chapter',
      });

      return { cdnUrl, legacyPath };
    }
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   * This utility ensures consistent file path construction with properly formatted numbers.
   *
   * @param num - The number to pad with leading zeros
   * @param places - The desired length after padding (total number of digits)
   * @returns A string with the padded number
   * @private
   * @example
   * // Returns "01" for chapter 1
   * this.zeroPad(1, 2);
   *
   * // Returns "001" for chapter 1 with 3 digits
   * this.zeroPad(1, 3);
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
