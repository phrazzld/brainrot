import {
  AssetNotFoundError,
  AssetUrlResolver,
  S3SignedUrlGenerator,
  SigningError,
} from '../types/dependencies';

/**
 * Parameters required to request a download URL.
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   */
  correlationId?: string;
}

/**
 * Service responsible for orchestrating the download URL resolution process.
 * Handles the logic to determine whether to return a Blob URL or generate a signed S3 URL.
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   *
   * @param assetUrlResolver - Service that resolves asset URLs with fallback logic
   * @param s3SignedUrlGenerator - Service that generates signed URLs for S3 objects
   * @param s3Endpoint - The S3 endpoint URL used to determine if URL signing is needed
   */
  constructor(
    private readonly assetUrlResolver: AssetUrlResolver,
    private readonly s3SignedUrlGenerator: S3SignedUrlGenerator,
    private readonly s3Endpoint: string
  ) {}

  /**
   * Gets a download URL for the requested asset.
   * Determines whether to return a Blob URL or a signed S3 URL based on the resolved URL.
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the final download URL
   * @throws {AssetNotFoundError} When the requested asset cannot be found
   * @throws {SigningError} When S3 URL signing fails
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Log entry with correlation ID if available
    if (correlationId) {
      console.debug(
        `[${correlationId}] Getting download URL for ${slug}/${type}${chapter ? `/${chapter}` : ''}`
      );
    }

    // Generate the legacy path based on the request parameters
    const legacyPath = this.generateLegacyPath(slug, type, chapter);

    try {
      // Attempt to get the asset URL with fallback mechanism
      const resolvedUrl = await this.assetUrlResolver.getAssetUrlWithFallback(legacyPath);

      // If no URL was resolved, throw an AssetNotFoundError
      if (!resolvedUrl) {
        if (correlationId) {
          console.warn(`[${correlationId}] Asset not found: ${legacyPath}`);
        }
        throw new AssetNotFoundError(`Asset not found: ${legacyPath}`);
      }

      // Check if the resolved URL is an S3 URL that needs signing
      if (resolvedUrl.includes(this.s3Endpoint)) {
        if (correlationId) {
          console.info(`[${correlationId}] Generating signed URL for S3 path: ${resolvedUrl}`);
        }

        try {
          // Generate a signed URL for the S3 path
          const signedUrl = await this.s3SignedUrlGenerator.createSignedS3Url(resolvedUrl);

          if (correlationId) {
            console.debug(`[${correlationId}] Successfully generated signed URL`);
          }

          return signedUrl;
        } catch (error) {
          if (correlationId) {
            console.error(`[${correlationId}] Signing error`, error);
          }

          // Wrap any signing errors and rethrow
          throw new SigningError(
            `Failed to generate signed URL for ${resolvedUrl}`,
            error instanceof Error ? error : undefined
          );
        }
      }

      // If not an S3 URL, return the resolved URL directly (e.g., Blob URL)
      if (correlationId) {
        console.debug(`[${correlationId}] Returning direct Blob URL`);
      }

      return resolvedUrl;
    } catch (error) {
      // If the resolver already threw an AssetNotFoundError, propagate it
      if (error instanceof AssetNotFoundError) {
        throw error;
      }

      // If it's a SigningError, propagate it
      if (error instanceof SigningError) {
        throw error;
      }

      // Log unexpected errors with correlation ID
      if (correlationId) {
        console.error(
          `[${correlationId}] Unexpected error resolving URL for ${legacyPath}:`,
          error
        );
      }

      // Otherwise, wrap in a new AssetNotFoundError
      throw new AssetNotFoundError(
        `Failed to resolve URL for ${legacyPath}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Generates the legacy file path based on request parameters.
   *
   * @param slug - The book slug
   * @param type - The download type (full or chapter)
   * @param chapter - Optional chapter number (required when type is 'chapter')
   * @returns The legacy file path
   * @private
   */
  private generateLegacyPath(slug: string, type: 'full' | 'chapter', chapter?: string): string {
    if (type === 'full') {
      return `/${slug}/audio/full-audiobook.mp3`;
    } else {
      if (!chapter) {
        throw new Error('Chapter parameter is required when type is "chapter"');
      }

      const paddedChapter = this.zeroPad(parseInt(chapter, 10), 2);
      return `/${slug}/audio/book-${paddedChapter}.mp3`;
    }
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   *
   * @param num - The number to pad
   * @param places - The desired length after padding
   * @returns A string with the padded number
   * @private
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
