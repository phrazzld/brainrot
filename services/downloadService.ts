import {
  AssetNotFoundError,
  AssetUrlResolver,
  S3SignedUrlGenerator,
  SigningError,
} from '../types/dependencies';
import { createRequestLogger } from '../utils/logger';

/**
 * Parameters required to request a download URL.
 * This interface encapsulates all the information needed to locate and generate
 * a download URL for an audio asset in the system.
 *
 * @interface
 * @example
 * // Request a full audiobook URL
 * const params: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'full',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 *
 * // Request a specific chapter URL
 * const chapterParams: DownloadRequestParams = {
 *   slug: 'the-odyssey',
 *   type: 'chapter',
 *   chapter: '3',
 *   correlationId: 'abcd-1234-efgh-5678'
 * };
 */
export interface DownloadRequestParams {
  /**
   * The slug identifier for the book or resource to download.
   * This is typically a URL-friendly version of the book title, like 'the-odyssey'.
   */
  slug: string;

  /**
   * The type of download requested - either a full book or a specific chapter.
   * - 'full': Retrieve the complete audiobook as a single file
   * - 'chapter': Retrieve a specific chapter (requires the 'chapter' parameter)
   */
  type: 'full' | 'chapter';

  /**
   * Optional chapter identifier. Required when type is 'chapter'.
   * For most books, this is a number (as a string) corresponding to the book chapter,
   * though some special chapters might have different identifiers.
   */
  chapter?: string;

  /**
   * Optional correlation ID for request tracing and logging.
   * Generated by the API route handler and propagated through the system.
   * This helps with tracing requests across different components and in logs.
   */
  correlationId?: string;
}

/**
 * Service responsible for orchestrating the download URL resolution process.
 * Handles the logic to determine whether to return a Blob URL or generate a signed S3 URL.
 *
 * This service acts as an orchestrator that:
 * 1. Constructs the legacy asset path based on the provided slug, type, and chapter parameters
 * 2. Delegates URL resolution to the AssetUrlResolver to find the asset
 * 3. Analyzes the resolved URL to determine if it needs S3 signing
 * 4. If S3 signing is needed, delegates to the S3SignedUrlGenerator
 * 5. Returns the appropriate URL (Blob or Signed S3) to the caller
 *
 * The service provides structured logging for all key operations to aid in debugging
 * and includes comprehensive error handling with appropriate error types.
 */
export class DownloadService {
  /**
   * Creates a new DownloadService instance.
   * Initializes the service with its required dependencies through dependency injection.
   * This constructor follows the Dependency Inversion Principle by accepting interfaces
   * rather than concrete implementations, which improves testability and flexibility.
   *
   * @param assetUrlResolver - Service that resolves asset URLs with fallback logic
   * @param s3SignedUrlGenerator - Service that generates signed URLs for S3 objects
   * @param s3Endpoint - The S3 endpoint URL used to determine if URL signing is needed
   * @example
   * const downloadService = new DownloadService(
   *   assetUrlResolver,
   *   createS3SignedUrlGenerator(),
   *   process.env.SPACES_ENDPOINT
   * );
   */
  constructor(
    private readonly assetUrlResolver: AssetUrlResolver,
    private readonly s3SignedUrlGenerator: S3SignedUrlGenerator,
    private readonly s3Endpoint: string
  ) {}

  /**
   * Gets a download URL for the requested asset.
   * Determines whether to return a Blob URL or a signed S3 URL based on the resolved URL.
   *
   * @param params - The download request parameters
   * @returns A Promise that resolves to the final download URL
   * @throws {AssetNotFoundError} When the requested asset cannot be found
   * @throws {SigningError} When S3 URL signing fails
   */
  async getDownloadUrl(params: DownloadRequestParams): Promise<string> {
    const { slug, type, chapter, correlationId } = params;

    // Create a logger with correlation ID if available
    const log = correlationId ? createRequestLogger(correlationId) : undefined;

    // Log method entry with detailed request parameters
    log?.debug({
      msg: 'Getting download URL',
      slug,
      type,
      chapter,
      action: 'downloadService.getDownloadUrl.entry',
    });

    // Generate the legacy path based on the request parameters
    const legacyPath = this.generateLegacyPath(slug, type, chapter, log);

    try {
      // Resolve the URL using asset resolver
      const resolvedUrl = await this.resolveAssetUrl(legacyPath, log);
      // Process the resolved URL (handle S3 vs Blob)
      return await this.processResolvedUrl(resolvedUrl, log);
    } catch (error) {
      return this.handleUrlResolutionError(error, legacyPath, log);
    }
  }

  /**
   * Resolves an asset URL using the asset resolver service.
   *
   * @param legacyPath - The legacy path to resolve
   * @param log - Optional logger instance
   * @returns The resolved URL
   * @throws {AssetNotFoundError} When the asset cannot be found
   * @private
   */
  private async resolveAssetUrl(
    legacyPath: string,
    log?: ReturnType<typeof createRequestLogger>
  ): Promise<string> {
    // Attempt to get the asset URL with fallback mechanism
    const resolvedUrl = await this.assetUrlResolver.getAssetUrlWithFallback(legacyPath);

    // If no URL was resolved, throw an AssetNotFoundError
    if (!resolvedUrl) {
      log?.warn({
        msg: 'Asset not found',
        legacyPath,
        action: 'downloadService.assetNotFound',
      });
      throw new AssetNotFoundError(`Asset not found: ${legacyPath}`);
    }

    return resolvedUrl;
  }

  /**
   * Processes a resolved URL by determining if it needs S3 signing.
   *
   * @param resolvedUrl - The URL to process
   * @param log - Optional logger instance
   * @returns The final URL (either signed S3 URL or direct Blob URL)
   * @throws {SigningError} When S3 URL signing fails
   * @private
   */
  private async processResolvedUrl(
    resolvedUrl: string,
    log?: ReturnType<typeof createRequestLogger>
  ): Promise<string> {
    // Check if the resolved URL is an S3 URL that needs signing
    if (resolvedUrl.includes(this.s3Endpoint)) {
      return await this.generateSignedS3Url(resolvedUrl, log);
    }

    // If not an S3 URL, return the resolved URL directly (e.g., Blob URL)
    log?.debug({
      msg: 'Returning direct Blob URL',
      urlType: 'blob',
      action: 'downloadService.blobUrlFound',
    });

    return resolvedUrl;
  }

  /**
   * Generates a signed S3 URL for the given S3 path.
   *
   * @param s3Url - The S3 URL to sign
   * @param log - Optional logger instance
   * @returns The signed S3 URL
   * @throws {SigningError} When signing fails
   * @private
   */
  private async generateSignedS3Url(
    s3Url: string,
    log?: ReturnType<typeof createRequestLogger>
  ): Promise<string> {
    log?.info({
      msg: 'Generating signed URL for S3 path',
      s3Path: s3Url,
      action: 'downloadService.generateSignedUrl.start',
    });

    try {
      // Generate a signed URL for the S3 path
      const signedUrl = await this.s3SignedUrlGenerator.createSignedS3Url(s3Url);

      log?.debug({
        msg: 'Successfully generated signed URL',
        action: 'downloadService.generateSignedUrl.success',
      });

      return signedUrl;
    } catch (error) {
      log?.error({
        msg: 'Failed to generate signed URL',
        s3Path: s3Url,
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        action: 'downloadService.generateSignedUrl.error',
      });

      // Wrap any signing errors and rethrow
      throw new SigningError(
        `Failed to generate signed URL for ${s3Url}`,
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Handles errors that occur during URL resolution.
   *
   * @param error - The error that occurred
   * @param legacyPath - The legacy path being processed
   * @param log - Optional logger instance
   * @returns Never returns as it always throws an error
   * @throws {AssetNotFoundError|SigningError} The appropriate error type
   * @private
   */
  private handleUrlResolutionError(
    error: unknown,
    legacyPath: string,
    log?: ReturnType<typeof createRequestLogger>
  ): never {
    // If the resolver already threw an AssetNotFoundError, propagate it
    if (error instanceof AssetNotFoundError) {
      throw error;
    }

    // If it's a SigningError, propagate it
    if (error instanceof SigningError) {
      throw error;
    }

    // Log unexpected errors with structured data
    log?.error({
      msg: 'Unexpected error resolving URL',
      legacyPath,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      action: 'downloadService.unexpectedError',
    });

    // Otherwise, wrap in a new AssetNotFoundError
    throw new AssetNotFoundError(
      `Failed to resolve URL for ${legacyPath}: ${error instanceof Error ? error.message : String(error)}`
    );
  }

  /**
   * Generates the legacy file path based on request parameters.
   *
   * @param slug - The book slug
   * @param type - The download type (full or chapter)
   * @param chapter - Optional chapter number (required when type is 'chapter')
   * @param log - Optional logger instance for structured logging
   * @returns The legacy file path
   * @private
   * @throws {Error} When type is 'chapter' but no chapter parameter is provided
   */
  private generateLegacyPath(
    slug: string,
    type: 'full' | 'chapter',
    chapter?: string,
    log?: ReturnType<typeof createRequestLogger>
  ): string {
    if (type === 'full') {
      const path = `/${slug}/audio/full-audiobook.mp3`;
      log?.debug({
        msg: 'Generated full audiobook path',
        slug,
        path,
        action: 'downloadService.generateLegacyPath.full',
      });
      return path;
    } else {
      if (!chapter) {
        log?.error({
          msg: 'Missing chapter parameter for chapter download',
          slug,
          type,
          action: 'downloadService.generateLegacyPath.error',
        });
        throw new Error('Chapter parameter is required when type is "chapter"');
      }

      const paddedChapter = this.zeroPad(parseInt(chapter, 10), 2);
      const path = `/${slug}/audio/book-${paddedChapter}.mp3`;
      log?.debug({
        msg: 'Generated chapter audiobook path',
        slug,
        chapter: paddedChapter,
        path,
        action: 'downloadService.generateLegacyPath.chapter',
      });
      return path;
    }
  }

  /**
   * Pads a number with leading zeros to reach the specified number of places.
   * This utility ensures consistent file path construction with properly formatted numbers.
   *
   * @param num - The number to pad with leading zeros
   * @param places - The desired length after padding (total number of digits)
   * @returns A string with the padded number
   * @private
   * @example
   * // Returns "01" for chapter 1
   * this.zeroPad(1, 2);
   *
   * // Returns "001" for chapter 1 with 3 digits
   * this.zeroPad(1, 3);
   */
  private zeroPad(num: number, places: number): string {
    const zero = places - num.toString().length + 1;
    return Array(+(zero > 0 && zero)).join('0') + num;
  }
}
